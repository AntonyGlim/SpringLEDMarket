**0:02** Обсуждение как добавить ордер в оплату Через Get /paypal/buy/id - проверить заказ.  
**0:05** Обсуждение ДЗ  
**0:11** Мой вопрос PostConstract  
**0:21** Закончили с моим проектом  
**0:27** Закончили с домашкой  
**0:28** Spring cloud  
**0:28** Микросервисы на примере приложения, которое собирает данные Оно имеет много модулей. Некоторые модули перегружены. И мы можем уперется в ограничение по производительности. Иногда модули могут быть написаны на других языках.  
**0:34** Если создать модули в виде отдельных сервисов на разнфых языках мы получим плюсы. Если сервис перегружен, то можем увеличить колличество сервисов. Можем запустить их на разных машинах. поэтому они должны общаться по REST API (json) сериализация  
**0:39** Как сделать микросервисы на java? Есть решение у NETFLIX, он интегрирован в спринг.  
**0:40** проблема Service1 port 8189-> (RestTemplate) -> Service2 port 8190 - если сервисов много - то большая проблема с портами  
**0:42** Решение EurekaDiscoveryService - мы точно знаем где его развернули (8761) и мы точно знаем этот порт. EurekaDiscoveryService та же знает кто где находится. Все сервисы регистрируются в эврике. и Эврика вытупает коммутатором.  
**0:45** она посылает сердцебиение проверяя живой ли сервис  
**0:46** Код, зависимости - родительский pom (версия cloud) нужен starter-web   
**0:47** dependencyManagment - версионирование модулей не идет параллельно, поэтому управлением версионирования он и занимается, поэтому у всех зависимостей нет версий  
**0:49** <repositories> - где искать репозитории  
**0:50** Эврика зависимость, @EnableEurekaService; файл application.yaml - вместо пропертис для настройки  
**0:51** про Эврика клиент - себя не регистрируй и не запоминай  
**0:52** Конфиг сервер; и демонстация ее работы  
**0:53** Подключение к эврике - прописываем зависимость в пом в настройках пишем имя клиента, порт, и стук на эндпоинт  
**0:54** Простой сервис на SpringBoot  
**0:55** Можем заинжектить эврику - демонстрация  
**0:57** Feign клиент - у него есть страница и настройки. Feign клиент - перенаправление на другой клиент, вызывает другой клиент. Связь между клиентами. Спрашиваем одного, а вызывается другой.  
**1:01** Фейн как подделк, маска над настоящим сервисом  
**1:02** Без фейн клиента общение через RestTemplate - больше кода - все время адреса и эндпоинты, а в фейн клиенте - мы этого не запоминаем. (histrix-client в этом проекте)  
**1:04** @LoadBalanced - в эврике если 1 сервис не справляется с нагрузкой то эврика может балансировать запросы при помощи балансировщика нагрузки Ribon - позволяет не писать полные адреса   
**1:07** Централизовано хранить конфиги. Включить конфиг сервер и зарегистрировать в эврики. можно настроить переодичность проверки настроек  
**1:10** Эврике можно в пропертях прописать где конфиг а конфигу, что только одна эврика стучалась  
**1:17** Если один из сервисов упал то есть hystrix - это обычный клиент - но способен прерывать цепочку, если один из сервисов упал  
**1:21** @HistrixCommand - защитная реакция если что-то упало. Не все упало по цепочке, а есть защита  
**1:22** Все сервисы знакомы через Эврику, а что со фронт-эндом?  
**1:23** ZuulProxy - все запросы из внешнего мира приходят на него. Он тоже на эврике рег-ся, висит на порте и является воротами  
**1:27** стартер зул   
**1:30** Как зул перенаправляет запросы на клиенты  
**1:34** Не работает Zuul  
**1:36** SecuredClient - если мы хотим аутентифицировать пользователя и значит при одном запросе должны вводить 100 раз логин и пароль, чтобы избежать - отдельный сервер аутентификации. Стуимся - получаем токин и его прокидываем.  
**1:38** auth-server - его настройки , он работает с базой    
**1:39** Отдельный сервер аутентификации  
**1:41** Объяснение про токены  
**1:45** JWT - JSON WEB Token имеет header, тело (payload) и подпись (sign).   
**1:46** в header - тип и прочее в payload - время жизни. sign смешение header + payload + алгоритм хэширования и + ключ. base64url (не шифрование) для всего сообщенияТокен не зашифрован  
**1:48** Проверка токена.   
**1:51** Про конфиги и как это все настроить в коде и про права  
**1:53** Генерация токенов и где находится ключ и как он должен храниться  
**1:54** CustomTokenEnhancer - находит юзера и добавяет инфо ?куда?  
**1:55** ?Важная штука?  
**1:56** Проверка через postmen  
**1:57** Как расшифровать token http://jwt.io  
**1:58** Стучим на защищенный сервис (secured-client в этом проекте)  
**1:59** его настройки  
**2:00** OAuth2restTemplate  
**2:02** Проверка через postmen. получили доступ  
**2:05** CoudPacket - объект DTO - наш модуль в коммоне.  
**2:08** Про Zuul - авторизаваться можем через него, н он рубит headers. не пропускает куки, и некоторые другие. Но мы можем указать, что не рубить.  
**2:09** OAuth2 feigen client на потом  
**2:11** Вопросы  
**2:12** ДЗ 2 микросервиса через эврику Хотим вывести на фронт сервисе список продуктов. Есть Второй продукт микросервис(не имеет фронта)   